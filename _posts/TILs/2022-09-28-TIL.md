---
title: "기록장"
---

Controller는 호출을 위한 호출만을 위한 수단으로 생각하자.

-> 그러면 내부 로직은 어떻게 !! 구성해

Serivce 단에서 처리하자 왜? 사용자는 내부 사정(Service)를 몰라도 되니까!

Domain을 통해 필요한 상자들을 세팅하고 -> Entity

다시 정리하면

Controller는 명령하달

Service는 명령 실행! 지금!! 명령을 수행하기 위한 준비물이 있는데 리모콘이 동작을 하기 위해 필요한건 "건전지"
이러한 건전지는 사용자가 이 건전지가 리모콘에 연결되면 어떤 방식으로 충전되고 어느 방식으로 전기가 이동하는지 몰라도 되니까 우리는 Servcie에 필요한 데이터를 사용자에게 요청을받아! 
그치만 ~ 사용자는 우리 사이트의 내부 구조를 하나하나 다 알 필요가 없으니 사용자에게 받는 데이터들은 DTO에 담아서 Controller에 전달하지

Serivce에서 reqeust받은 데이터를 Entity(Domain) 단에서 이쁘게 포장하고 그걸로 신나게 연산을 하고 어디 보내고~ 저기 보내고를 수행하지

이때 Service에서 내부로직이 수행된 이후에 뱉어내는 결과물이 존재하는데 이 결과물들은 ResponseDto에 담아서~ 사용자가 조작 할 수 없게 getter만 가능하도록 Dto를 설계하는게 좋다~~ 이말이야

---
# 제너릭 타입은 Low가 싫어요

함수가 실행되고 행동을 수행하기 위한 준비물도 받았고, 이제는 행동한 결과를 눈에 보이도록 줘야하는데, 이때 데이터의 타입이라던가, 데이터의 자료구조가 슉슉 바뀌던가 결과값의 Type을 에측하기 힘든 상황이 오는데 , 제너릭타입은 클래스의 내부가아닌 외부에서 사용자에 의해 지정되는 것을 말하는데, 나는 가장 많이 사용한건 반환타입에 제너릭 반환자 형태로 사용하여 내부 로직에서 뱉는 값의 데이터 타입을 정확하게 명시할 필요 없이 경계만 지정 해 주는 방법으로 많이 사용했다~

1. 제너릭 타입을 사용 할 경우 경계를 벗어난 데이터 타입이나 데이터가 들어 올 경우 컴파일 단계에서 오류를 발견 할 수 있어
2. 비슷한 기능을 가진 함수들을 묶거나 재활용 할 때 경계가 비슷한 Output을 내보낸다면 묶어서 사용 할 수 있어 코드의 재사용성이 올라가지.


---

# Query는 null을 찾지는 못하는데 싫어요

1. Query는 모래성인가

    Mysql은 db에 저장된 데이터를 빠르게 불러오기 위해 인덱스와 데이터 파일을 따로 관리하는데 B-tree 구조 형태로 데이터를 루트 노드, 브랜치, 리프 로 접근해 데이터 파일을 찾아가는 형태인데
    Select 과정중에서 검증되지 않은 데이터를 Select하거나 null인 데이터를 참조하게 된다면 NullpointException을 만날 수 있다.
   
## 📌 FUTURE



### ✅ Week list
- 


---

#   남들이 땅을 뚫고 나올 때, 나는 왜 땅 위로 나오지 못 할까 조급해 하지말자.
#   나는 죽순 언젠가 땅을 뚫고 올라갈 때, 성장하기 위한 에너지를 비축하고 있다
