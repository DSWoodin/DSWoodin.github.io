---
layout: post
tags: [.net, roslyn, refactoring, analysis, analyzer, syntax tree]
title: Adventures with Roslyn .NET, Part 2 - Analyzer
author: emir_osmanoski
comments: true
image: /images/2020-06-11-Roslyn-Syntax-Analyzer-Multiple-Method-Calls/00_logo.png
cover-img: /images/2020-06-11-Roslyn-Syntax-Analyzer-Multiple-Method-Calls/000_cover.png
share-img: /images/2020-06-11-Roslyn-Syntax-Analyzer-Multiple-Method-Calls/00_logo.png
meta-description: An introduction to a basic Analyzer
---

## Introduction 
The previous part of this series served as an introduction to both Roslyn in general and the problem that we will tackle with the analyzer in this second part.

We are now going to look at the Analyzer details. As a lot of what will be discussed wi relies mostly on the introduction and problem statement from the previous part it's
 good to have the link:

 TODO : Link here 
## Analyzer Basic Setup 2

In the previous post we mentioned that Roslyn offers a set of API's which allow
us to hook into the .NET Compiler pipeline that runs in Visual Studio.
T
This pipeline which includes Syntax Analysis is constantly running as it's
needed for some of the Key IDE features to work.

For example the Syntax Highlighting feature needs to know which parts of the
text are variables, which are keywords, methods, expressions and so on so it can apply different styles to different types of syntax.

> As we write code it's constantly analyzed. As we complete variable names, statements and expressions the visual studio ide does perform certain default actions to help us with the code. We can utilize this approach to hook in our own methods that can run our own custom analysis.

Building on top of this we can use the Roslyn API to hook into this pipeline. Through what is called an Analyzer will be basically saying the following:

- Roslyn, please tell me when you identify a certain type of oken or Syntax while you are processing this source file.

The general approach is then to do our own custom/specific analysis when we get notified that what we are interested in has been detected. This is maybe best illustrated
by the simple example that comes out of the box with the `Analyzer with Code Fix` template which we'll look at next.

## Template Default setup

Let's have a look at how some of the above concept are covered in the project/extension generated by default from the  template.

> The template generates a project that addresses a fictional code smell of lowercase names for types.
> For example when defining a class `public class Animal` the analyzer and fix provider will propose we change the class name to `public class ANIMAL`. For the purposes of the article

The first thing we do to register an analyzer is going to be inherit from a specific base class,  
`DiagnosticAnalyzer` and decorate it with the `DiagnosticAnalyzer` attribute setting the language to C#:

``` csharp
[DiagnosticAnalyzer(LanguageNames.CSharp)]
public class UpperCaseTypeAnalyzer : DiagnosticAnalyzer
```

This allows us to override the `Initialize` method where we can actually let Roslyn:

``` csharp
public override void Initialize(AnalysisContext context)
{
    // TODO: Consider registering other actions 
    // that act on syntax instead of or in addition to symbols
    //
    // See https://github.com/dotnet/roslyn/blob/master/docs/analyzers/Analyzer%20Actions%20Semantics.md for more information
    context.RegisterSymbolAction(AnalyzeSymbol, SymbolKind.NamedType);
}
```

The initialize method which runs when our Analyzer boots up is going to use the `AnalysisContext` ro register an `Action` with Roslyn.

The example uses `RegisterSymbolAction`. The description of the method states the following:


Register an action to be executed at completion of semantic analysis of an ISymbol with an appropriate Kind. A symbol action reports Diagnostics about ISymbols.

At this point we can make a difference between at least two types of analysis we can conduct on our code base. In other words we can register actions we want performed an

1. Syntax Analysis
   1. Deals with the structure of the code by looking at how code statements/expressions are structured and organized to form our program.
   2. Primary deals with Syntax Nodes and Syntax Tokens.
   3. Even though we can analyze multiple files at one given time we can only look at the syntax of a single file.
2. Semantic Analysis
   1. Deals with the meaning behind the syntax.
   2. Among other things it's primary construct are the Symbols based on the ISymbol interface.
   3. The semantic analysis can span multiple files, for example we can get information for variables with types defined in other files.
   4. Symbols are defined through some syntax that has an associated meaning.


The template analyzer registers a callback each time Roslyn detects semantic changes, in this case when a new Symbol is detected and more specifically a `Named Type` Symbol. Basically while this sample analysis(extension) would be running in an instance of Visual Studio each time we declare a new Type (Class) the callback method, `AnalyzeSymbol`  would be called.

Let's now look at what exactly `AnalyzeSymbol` does:

``` csharp
private static void AnalyzeSymbol(SymbolAnalysisContext context)
{
   // TODO: Replace the following code with your own analysis, generating Diagnostic objects for any issues you find
   var namedTypeSymbol = (INamedTypeSymbol)context.Symbol;

   // Find just those named type symbols with names containing lowercase letters.
   if (namedTypeSymbol.Name.ToCharArray().Any(char.IsLower))
   {
         // For all such symbols, produce a diagnostic.
         var diagnostic = Diagnostic.Create(Rule, namedTypeSymbol.Locations[0], namedTypeSymbol.Name);

         context.ReportDiagnostic(diagnostic);
   }
}
```

This is where we start to get a bit more into specifics around different types
of Symbols.

We see that we can access the Symbol that was detected through `context.Symbol`.
The code casts it to the specific `INamedTypeSymbol` which provides the
following [methods and
properties](https://docs.microsoft.com/en-us/dotnet/api/microsoft.codeanalysis.inamedtypesymbol?view=roslyn-dotnet),
which we will use.

{: .box-note}
The `SymbolAnalysisContext` is the key interface we have at this point with the rest of the Roslyn API. It provides the information we are interested in as well as the key feature of reporting if we find that something is not up to the code standard we are trying to enforce.
{: .box-note}

That is ony of many possible implementation of the general `ISymbol` interface
which provided additional properties and methods for us to further analyze
things we might be interested for in the declared Symbol. For more information
on the other types of `ISymbol` refer this
[link.](https://docs.microsoft.com/en-us/dotnet/api/microsoft.codeanalysis.isymbol?view=roslyn-dotnet)

> The (INamedTypeSymbol) cast is safe and does not run the risk of the `context.Symbol` implementing a different interface because when we registered the SymbolAction we specifically said we are interested only in `SymbolKind.NamedType`.

So let's now have a look at the key part of the code. Checking if this new Symbol breaks our hypothetical code rule. That's as simple as checking if at least one character in the name of the Named Type Symbol is lowercase:

``` csharp
if (namedTypeSymbol.Name.ToCharArray().Any(char.IsLower))
```

If that is true all that is left to do is to use the `SymbolAnalysisContext` to actually report the issue:

``` csharp
// For all such symbols, produce a diagnostic.
var diagnostic = Diagnostic.Create(Rule, namedTypeSymbol.Locations[0], namedTypeSymbol.Name);
context.ReportDiagnostic(diagnostic);
```

A couple of things to note here:

**Rule**

The `Rule` object is a static property of type `DiagnosticDescriptor`. It's an object that describes what the Analyzer does and comes pre-built for us through the template. 

It's our interface with some of the UI elements in the Visual Studio IDE when our extension and analyzer is running and reporting diagnostics.

We also use it do define the Category of the diagnostic and the severity. More information about the class can be found [here.](https://docs.microsoft.com/en-us/dotnet/api/microsoft.codeanalysis.diagnosticdescriptor?view=roslyn-dotnet)

``` csharp
public const string DiagnosticId = "UpperCaseType";

// You can change these strings in the Resources.resx file. If you do not want your analyzer to be localize-able, you can use regular strings for Title and MessageFormat.
// See https://github.com/dotnet/roslyn/blob/master/docs/analyzers/Localizing%20Analyzers.md for more on localization
private static readonly LocalizableString Title = 
new LocalizableResourceString(nameof(Resources.AnalyzerTitle), Resources.ResourceManager, typeof(Resources));

private static readonly LocalizableString MessageFormat = 
new LocalizableResourceString(nameof(Resources.AnalyzerMessageFormat), Resources.ResourceManager, typeof(Resources));

private static readonly LocalizableString Description = 
new LocalizableResourceString(nameof(Resources.AnalyzerDescription), Resources.ResourceManager, typeof(Resources));

private const string Category = "Naming";

private static DiagnosticDescriptor Rule =
 new DiagnosticDescriptor(DiagnosticId, Title, MessageFormat, Category, 
                          DiagnosticSeverity.Warning, isEnabledByDefault: true, description: Description);
```

**Location**

The location of the issue associated with the diagnostic. This is where we can use the actual namedTypeSymbol analyzed and get the location from it's Locations list.

> The location is a list because of things like Partial Classes. In that case the named symbol is going to be declared in multiple locations.

**Message Arguments**
 
The third parameter when creating the rule is a list of message arguments. This is where we circle back to the DiagnosticDescriptor and the `MessageFormat` parameter. The arguments we provide will be used in the MessageFormat which for the starting template is `Type name '{0}' contains lowercase letters`

And that is basically it! :heavy_check_mark:

This template project can be published generating an extension installation
file. We can also Debug (F5) the .VSIX which will run a "Test" instance of Visual Studio with the extension installed and we can see how the sample analyzer reports the diagnostic:

![Reported Diagnostic](/images/2020-11-02-Roslyn-Syntax-Analyzer-Part-2/01_ReportedDiagnostic.png)


## Sample Problem Analyzer (Multiple Method Calls)

We've now covered a very general and basic example of how this works. The Analyzer for the  problem statement from the [previous part](https://blog.emirosmanoski.mk/2020-06-11-Roslyn-Syntax-Analyzer-Multiple-Method-Calls/#the-sample-problem) of this will follow this general approach using the same API to register against Roslyn/Compiler actions.

We are just going to be interested in slightly different code "written" events and will do expand the actual check to something more complicated.

> Reminder of problem statement: We want to be notified if we are unnecessarily calling the same function multiple times within the current scope (method/function) instead of re-using the return results.

{: .box-error}
The analyzer presented is potentially going to be naive in certain scenarios and will probably report false positives and sometimes even ignore cases that it needs to report. It's a work in progress proof of concept! 
{: .box-error}

### Initialize and Register our Callback

We want to start with Roslyn letting us know when method scope has been defined. We don't care about any function calls in other methods in the same class. We can't re-use the results from a call in the current method/function in the other method functions, or at least not with the simple analysis and fix provided we will be defining.

> The Method Scope is a naive look at things as there might be potentially scenarios where the first function call is within an if block in the method scope while the second unnecessary duplicate is outside the if method. This could be a complex scenario where the order of method invocation in scopes matter. Additionally looking at methods might be valid but further Semantic/Code Reachability analysis would be needed - which is currently out of scope for our example!

{: .box-note}
While trying this out one of the resources that was very useful to get around some of the initial issues was the [Roslyn SDK Samples Repository](https://github.com/dotnet/roslyn-sdk/tree/master/samples/CSharp/Analyzers/Analyzers.Implementation/StatefulAnalyzers).
{: .box-note}


To achieve our goal of analyzing code within Method Blocks we are going to use
the `RegisterCodeBlockStartAction` registration. What we are going to register
is not actually going to be the method (like previously) that will actually
report the diagnostic. 

It will be a method that will register the code that will do the analysis for each code block. We will see how and why we to this:

``` csharp

context.RegisterCodeBlockStartAction<SyntaxKind>(analysisContext =>
{
      if (analysisContext.OwningSymbol.Kind != SymbolKind.Method)
      {
         return;
      }

      // create a new analyzer for this code block
      var analyzer = new StatefulNodeAnalyzer();

      analysisContext.RegisterSyntaxNodeAction(
         ctx => analyzer.AnalyzeSyntaxNode(ctx, analysisContext.CodeBlock),
         SyntaxKind.InvocationExpression);
});
```

What we are basically saying here is that any time a `Code Block` (CodeBlockStartAction) which is a `Method` (the OwningSymbol.Kind Check) is analyzed we register a `SyntaxNodeAction` that will only look at SyntaxNodes of type `SyntaxKind.InvocationExpression`!

> Invocation expressions syntax is exactly what we are interested in as it is how function calls are represented.

What we are doing a bit differently from the template example is create our own custom `StatefulNodeAnalyzer` and manually invoke the `AnalyzeSyntaxNode` method by also passing the `CodeBlock` provided from the `RegisterCodeBlockStartAction` `AnalysisContext`.  We do this because we want to know where to start the search of multiple method invocations (_in the code block!_). 


We are now in the following position where:

1. We've stated that we want to know when C# Code Blocks Stat
2. We only look at Method blocks
3. When dealing with such Method Blocks we register a SyntaxNodeAction only for [InvocationExpressionSyntax](https://docs.microsoft.com/en-us/dotnet/api/microsoft.codeanalysis.csharp.syntax.invocationexpressionsyntax?view=roslyn-dotnet)
4. When such [InvocationExpressionSyntax](https://docs.microsoft.com/en-us/dotnet/api/microsoft.codeanalysis.csharp.syntax.invocationexpressionsyntax?view=roslyn-dotnet) is found (a method/function call is encountered) we run the custom AnalyzeSyntaxCode functionality.
5. We pass the Method Code Block through to as we will see narrow the search of a potentially another call.

### Analyzing & finding multiple method calls

Now let's look at the `AnalyzeSyntaxNode` by looking at bigger pieces of code that deal with separate concerns of the analysis. We will see that we won't be just looking at the Syntax but also analyzing the Semantics and meaning of the code.

{: .box-note}
One important practice is to stop analyzing as soon as possible to save on performance. That's reflected in the code bellow which runs small quick checks trying to in a way discard the SyntaxNode as a further candidate for analysis with certain initial checks.
{: .box-note}


#### Gathering Initial Information and Checks

The start of the Analysis: 

``` csharp
public void AnalyzeSyntaxNode(SyntaxNodeAnalysisContext context,
         SyntaxNode methodCodeBlock)
{
         // we are going to run the analysis in the context of the code block
         // which for us would be the method.
         //
         // We want to search for any invocations within that method code block - for now!

         var semanticModel = context.SemanticModel;

         var node = (InvocationExpressionSyntax)context.Node;

         var methodSymbol = (IMethodSymbol)semanticModel.GetSymbolInfo(node).Symbol;

         if (methodSymbol != null && methodSymbol.ReturnsVoid)
         {
            return;
         }

         // ....
         // .... More code to follow!

}
```

We start the analysis by getting the [Semantic Model](https://docs.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/get-started/semantic-analysis) and the InvocationExpressionSyntax Node ( which is very similar as in the basic example).

The next line queries the `Semantic` model for information about our InvocationExpression `Syntax` Node. What we expect to get is a Semantic [IMethodSymbol](https://docs.microsoft.com/en-us/dotnet/api/microsoft.codeanalysis.imethodsymbol?view=roslyn-dotnet). This object if available will give us meaningful information about the method we are looking at on which we will make certain decisions.

> Please have a look at least at the properties and methods available on through the  IMethodSymbol interface. We can see how howe much information we get through our Semantic Model from an Invocation Expression Syntax. The semantic model looks at the big picture behinds just the collection of characters `Foo(paramOne);` and provides us with information like `IsExtensionMethod` or `IsAbstract`

From there the first thing we check is if the Method returns `void` (using `ReturnsVoid`) or in other words does not return anything. This is important for solving our problem statement by re-using the returned value of the first call.

We stop further analysis if there is no return type as we can't actually provide a solution to the code-smell! This circles back to the optimization argument of stopping as soon as possible _(of course unless dealing with a true correctable issue)_.

{: .box-note}
Note that the `IMethodSymbol` refers to the "definition" of the method. The value of the `ReturnsVoid` property is not going to change regardless of where or how many times we call the method.
{: .box-note}

#### Counting how many times we invoke the function

The next block of code in the analyzer actually checks if we have a problem to solve based on the key problem statement of multiple calls. If the method is actually only called once there is nothing further to analyze and solve.

We do several count checks that cover different scenarios:

``` csharp
// ----
// ---- Previous Code

// Traverse the code block
var allInvocationExpressions =
   methodCodeBlock.DescendantNodes().OfType<InvocationExpressionSyntax>().ToList();

// If there are no other invocations except the current one tracked by the 'node'
// don't do any other processing.
if (allInvocationExpressions.Count == 1)
{
   return;
}

// We want to get only the nodes that refer to the same function I'm checking for in the current
// method block.

// If for example we had a call to OurMethod(input) and Console.WriteLine()

var currentNodeExpression = node.Expression.ToString();

var invocationsOnlyWithCurrentNodeExpression =
   allInvocationExpressions.Where(expressionNode =>
      expressionNode.Expression.ToString().Equals(currentNodeExpression)).ToList();

// if we end up with  1 then there are no other invocations matching current node.
if (invocationsOnlyWithCurrentNodeExpression.Count == 1)
{
   return;
}

// Now we get the invocations that are not the Current one by looking at 
// the location where they start in the code block
var otherInvocationsMatchingCurrent =
   invocationsOnlyWithCurrentNodeExpression.Where(inv => inv.Span.Start != node.Span.Start).ToList();

// ----
// ---- More Code

```

In an attempt of maybe over-eager optimization we first check if there is at
least one more InvocationExpression Syntax Node for any method within the same
code block. If method is the only call we can stop further analysis.

> The code and comments make references to current node or current method. That
> refers to the point that this analyzer code has been invoked specifically
> after the engineer has typed/completed code that expresses a method call. He
> might have written such code before and he will probably write such code after
> and each time this analysis will run and we can look at the previous/other
> methods he has written.


Next we check if the other InvocationExpressions we found (at least one or multiple), that have been written some time in the past, actually invoke the same method that is being invoked with the current invocation syntax!

We do this by looking at the expression property and filter the `allInvocationExpressions` from the previous check to only those with the same expression. To illustrate, let's look at the expression property of the following `Foo` method call as seen in the all important `Syntax Visualizer`:

``` csharp
class Program
{
   static void Main(string[] args)
   {
      var input = 4;
      int x, y;

      x = Foo(input);
      y = Foo(input);

      Console.WriteLine(x);
      Console.WriteLine(y);
   }

   static int Foo(int i)
   {
      return 4;
   }
}
```

![Expressions in Tree](/images/2020-11-02-Roslyn-Syntax-Analyzer-Part-2/02_InvocationExpression_ExpressionProperty.png)

From there a simple filter based on that property will give us all the invocations within our method code block that are calling the same method. If it's still just the one such method (the current one) we stop analyzing.

If there are multiple such calls at this point it means that:

> A method that returns a value has been called multiple times within this code block.

Unfortunately, this is still not enough for us to determine that there is a problem with our code. It could very well mean that each call is using different parameters/argument values. It's reasonable to assume that if a method has been called multiple times with different parameters the invocation has been intentional and we expect different results.

So we will take the analysis a step further and check if all the other invocations we found (besides the current one) have the same argument list. For that we create the `otherInvocationsMatchingCurrent` list which uses the `Span.Start` property to only get the invocations that are not our current one based on the occurence in the code block.

{: .box-warning}
 **Warning:** Even with the argument check this is by no means a complete solution to the analysis. I don't think for such a problem a complete full-proof, "Yes these X method calls always return the same result" is even possible. For starters we can consider the opposite of [Pure Functions](https://www.sitepoint.com/functional-programming-pure-functions/#:~:text=A%20pure%20function%20is%20a,always%20return%20the%20same%20result.) and the challenge they present for the approach. Therefore we  present the analysis findings and fixes as a "For your consideration" proposal and allow the engineers to make the right calls of applying the fix or ignoring the diagnostic.
{: .box-warning}

#### Checking Arguments and Reporting Diagnostics

We are now quite close to making our final decisions on wether a problem with our method invocations is present in our code, or specifically a method code block. The final part of the code:

``` csharp
 // simple argument matching
var currentArgumentsList = node.ArgumentList.Arguments;

var invocationsWithMatchingArgumentList = otherInvocationsMatchingCurrent.Where(inv =>
   ArgumentListsMatch(currentArgumentsList, inv.ArgumentList.Arguments)).ToList();

if (invocationsWithMatchingArgumentList.Count > 0)
{
   var methodName = node.Expression.ToString();
   var argumentList = node.ArgumentList.Arguments.ToString();

   var diagnostic = Diagnostic.Create(Rule, node.GetLocation(), methodName, argumentList);

   context.ReportDiagnostic(diagnostic);
}
```

Here we use the `ArgumentList.Arguments` property on the
[InvocationExpressionSyntax](https://docs.microsoft.com/en-us/dotnet/api/microsoft.codeanalysis.csharp.syntax.invocationexpressionsyntax?view=roslyn-dotnet)
nodes for the current node/call and all the other matching Invocation
Expressions (`otherInvocationsMatchingCurrent`). We are looking for at least one
of the other Invocations to have a matching argument list, a check done in the
`ArgumentListsMatch` helper method that just takes two objects representing the
argument list syntax for both invocations and run's comparisons.

Let's take a look at that method next, before circling back to reporting the
diagnostic.

``` csharp
private bool ArgumentListsMatch(SeparatedSyntaxList<ArgumentSyntax> originalArgumentList,
      SeparatedSyntaxList<ArgumentSyntax> toMatchArgumentList)
{
      if (originalArgumentList.Count != toMatchArgumentList.Count)
      {
         return false;
      }

      for (int i = 0; i < originalArgumentList.Count; i++)
      {
         var originalCandidate = originalArgumentList[i];
         var toMatchCandidate = toMatchArgumentList[i];

         if (originalCandidate.Expression.ToString() != toMatchCandidate.Expression.ToString())
         {
            return false;
         }
      }

      return true;
}
```

The method operates over two [SeparatedSyntaxList<ArgumentSyntax>](https://docs.microsoft.com/en-us/dotnet/api/microsoft.codeanalysis.csharp.syntax.argumentlistsyntax.arguments?view=roslyn-dotnet#Microsoft_CodeAnalysis_CSharp_Syntax_ArgumentListSyntax_Arguments) objects that represent our arguments.

The check is very simple and is based on the number of arguments and the
`ArgumentSyntax` `Expression` property. Once again we can look at the 
`Syntax Analyzer` and the `Foo()` method from the previous example to see how the properties of an `Argument` in the `Argument List`:

![Expressions in Tree](/images/2020-11-02-Roslyn-Syntax-Analyzer-Part-2/03_InvocationExpression_Arguments.png)

{: .box-warning}
 **Warning:** The argument check is also not complete and would not cover all scenarios to fully identify if the argument lists match. The check also ignores the "value" aspect. Whereas they work when we are maybe dealing with literals like: `Foo(2)` or `Bar("Input Parameter")` they would fail if we deal with the same "value" passed by a different name. This is definitely an area that could use some improvement in the future in terms of presenting these cases to the engineer as something to be resolved within their discretion
{: .box-warning}


##### Reporting Diagnostic

If the simple argument check finds that the methods are invoked with the same arguments we can proceed to report an issue. There is certainly something that can be done to save on computing resources or at least give the engineer the notification and the chance to review their code!

The Diagnostic report has nothing out of the ordinary when compared to the sample/template reporting. We still define a `Diagnostic Descriptor`:


``` csharp
public const string DiagnosticId = "MultipleMethodCallDiagnosticAnalyzer";

private static readonly string Title = "Multiple Method Invocation";

public static readonly string MessageFormat =
   @"{0} called multiple times with identical arguments: [{1}]";

private static readonly string Description = "Multiple Identical Method Invocation";

private const string Category = "Usage";

private static readonly DiagnosticDescriptor Rule = new DiagnosticDescriptor(DiagnosticId, Title, MessageFormat, Category, DiagnosticSeverity.Warning, true, Description);
```

The slight difference is the amount of Message Arguments and how we get the
Diagnostic Location, through using the
[`GetLocation()`](https://docs.microsoft.com/en-us/dotnet/api/microsoft.codeanalysis.csharp.csharpsyntaxnode.getlocation?view=roslyn-dotnet#Microsoft_CodeAnalysis_CSharp_CSharpSyntaxNode_GetLocation)
method on the
[`InvocationExpressionSyntax`](https://docs.microsoft.com/en-us/dotnet/api/microsoft.codeanalysis.csharp.syntax.invocationexpressionsyntax?view=roslyn-dotnet)
class!

{: .box-note}
**Information:** Remember that the analysis is constantly running so in the simple case of the double `Foo()` method invocation we will actually report two diagnostics in two different locations where we call the method. After we finish writing/coding the second call - which duplicates on the first one we also run the analysis on the first method as well, which now duplicates on the just finished invocation. :recycle:
{: .box-note}

## In Action

So let's see this in action, specifically maybe using our sample `Foo()` method program. The IDE does report an issue with having two such method calls that have a return value and are invoked with the same arguments.

We can see that both the methods have a `warning` squiggly line underlying the invocations:

![Squiggly Lines under multiple Foo Method Invocation showing there have been reported diagnostics](/images/2020-11-02-Roslyn-Syntax-Analyzer-Part-2/04_Foo_Diagnostic.png_InvocationExpression_Arguments.png)

And if we hover over any of the two `warnings` we get, as expected, the full IDE experience reporting our diagnostic:


![Full details of reported multiple invocation warnings matching message format](/images/2020-11-02-Roslyn-Syntax-Analyzer-Part-2/05_Foo_DiagnosticDetails.png_Foo_Diagnostic.png_InvocationExpression_Arguments.png)



## Summary

TODO:

## Additional Resources

https://joshvarty.com/learn-roslyn-now/
