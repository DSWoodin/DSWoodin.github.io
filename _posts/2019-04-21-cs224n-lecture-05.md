---
layout: post
title: CS224n Lecture 05 정리
subtitle: Dependency Parsing
tags: [CS224n]
comments: true
---

CS224n 강의를 들은 내용을 정리할 계획이다. 사내에서 스터디를 진행하며 늦게나마 하나씩 내용을 정리해서 올릴 예정이다.

이번 강의는 NLP를 위한 *언어학*적인 내용을 다루고 있다. 개인적으로 CS224n 내용을 학술적으로 접근하기 보다는, 엔지니어링 측면에서 배우고자하기 때문에 이번 강의는 간략히 정리하고 넘어가려 한다.

### Two views of linguistic structure: Constituency vs. Dependency

정리에 앞서 이해를 돕기 위해 두 방법을 비교하면 아래 그림과 같다.

![Constituency vs Dependency](https://seo-jinbro.github.io/img/cs224n/lecture05/constituency_vs_dependency.png)
(출처: https://lee6boy.wordpress.com/2013/06/28/parsing-dependency-parsing-graph-based-parsing%EC%9D%B4-%EB%AD%94%EA%B0%80/)


#### Constituency Parsing

(=phrase structure grammar = context-free grammars = CFGs)

Constituency Parsing 은 *한국 학교*에서 영어 문법을 처음 배울 때를 생각하면 좋을 것 같다.
각 words 를 small phrases 로 묶고,  small phrases 를 각각 bigger phrases 로 재귀적으로 묶는 과정이다.
아래 예시를 보면, 주어진 단어들에 대해 *POS tagging* 을 하고, 이후 품사별로 가능한 조합에 따라 구를 묶는다.

![Phrase structure](https://seo-jinbro.github.io/img/cs224n/lecture05/phrase-structure.png)

영어와 같이 어순이 규칙적인 언어들에서 많이 쓰였다고 한다.(지금은...)

#### Dependency Parsing

Dependency Parsing 은 주어진 문장에서 단어들 사이의 의존성을 표시하도록 나타내는 방법이다.
어떤 단어가 다른 단어의 *head* 인지 *dependent* 인지 판단하여 의존 관계를 만든다. 혹여 생략된 부분이 있어 명시적으로 연결할 수 없다면, fake node 를 추가하여 *tree*를 만든다.
(*head* 이거나, 혹은 무조건 정확히 하나의 node에 dependency 가 있도록)

![Dependency structure](https://seo-jinbro.github.io/img/cs224n/lecture05/dependency-structure.png)

과정 중에 고려해야할 점은 다음과 같다. (각각에 대한 자세한 설명은 필요시 찾아보도록 생략하겠다.)

* Bilexical affinities
* Dependency distance
* Intervening material
* Valency of heads
* Projectivity

**Methods of Dependency Parsing**

그러면 *Dependency Parsing* 을 구현하는 방법에는 어떤 것이 있을까?
강의에 소개된 것은 아래와 같이 4개이고, 그 중에서도 *Transition-based parsing* 에 대해 다룬다.

1. Dynamic programming (O(n^3))
2. Graph algorithms (MST for a sentence)
3. Constraint Satisfaction (Edges are eliminated that don’t satisfy hard constraints)
4. Transition-based parsing (= deterministic dependency parsing, Greedy choice of attachments guided by good machine learning classifiers)

**Transition-based parsing**

Stack, Buffer, (Left | Right)-Arc 로 구성되어 다음과 같은 방식으로 Parsing 한다.

![Transition-based parser](https://seo-jinbro.github.io/img/cs224n/lecture05/transition-based-parsing.png)
![Transition-based parser 2](https://seo-jinbro.github.io/img/cs224n/lecture05/transition-based-parsing-2.png)

**Ambiguity**

강의 중반에 Ambiguity 에 관한 내용을 살짝 다루었다. 

자연어는 굉장히 효율적인 (경제적인) 방식으로 소통하기 때문에, ambiguity 가 발생한다.

강의에 나온 유형은 다음과 같다. 정리를 위해 적어두고 자세한 설명은 생략한다.

* Prepositional phrase attachment ambiguity
> Scientists count whales from space

* PP attachment ambiguities multiply
> The board approved [its acquisition] [by Royal Trustco Ltd.] [of Toronto] [for $27 a share] [at its monthly metting.]

* Coordination scope ambiguity
> Doctor: No heart, cognitive issues (Trump 관련 의혹을 다룬 기사의 headline)

* Adjectival Modifier Ambiguity
> Students get first hand job experience (ㅗㅜㅑ...)

* Verb Phrase (VP) attachment ambiguity
> Mutilated body washes up on Rio beach to be used for Olympics beach volleyball

Ambiguity 를 다루며 가능한 조합들에 대해 설명할 때, 잠시 **Catalan numbers** 에 관해서 다루고 있다.
> Catalan numbers: C n = (2n)!/[(n+1)!n!]

조합론 문제를 풀다보면 가끔 마주하는 문제인데, 뜬금없이 왜 나왔냐 하면 *n개의 pair* 를 어떻게 묶는 방법에 관한 수이기 때문이다.
위의 *PP attachment ambiguities multiply* 에서 []로 묶인 부분에서, 다양한 constituents 를 어떤 식으로 묶느냐에 따라 해석이 달라질 수 있기 때문이다.

자세한 설명은 [카탈란 수](https://suhak.tistory.com/77) 를 참조하면 좋다.

그 외에도, 강의 후반부에는 다양한 Dependency Parser 에 관한 방법론적 내용을 다룬다.
마지막으로 그 중 *Neural Network* 로 처리하여 성능 향상 및 Computational Efficiency 를 얻었다는 내용에 대해 나온다.
이 부분은 추후에 필요시 다시 보면 될 것 같다.